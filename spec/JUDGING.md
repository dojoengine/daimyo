# Game Jam Judging

Pairwise-preference judging for Dojo game jams.

## Overview

Game jam entries are judged through pairwise comparisons by community Sensei.
Judges are presented with two games at a time and rate their preference on a 5-point Likert scale.
Final rankings are calculated using a PageRank-style spectral method (principal eigenvector of the normalized transition matrix).

## Goals

1. **Fair Evaluation**: Pairwise comparison removes the need for absolute scoring, reducing bias
2. **Community Involvement**: Leverage the Sensei role as trusted judges
3. **GitHub Integration**: Pull game jam entries directly from GitHub PRs
4. **Transparent Rankings**: Spectral method provides mathematically grounded rankings that handle intransitivity naturally

## Architecture

**Backend**: Express REST API added alongside existing Discord.js client in single Node.js process.

**Frontend**: Vite + React SPA deployed to Vercel (shared with planned wallet-linking feature from BLOCKCHAIN.md).

**Flow**:
1. GitHub workflow in game-jams repo screens submissions and outputs `entries.yaml`
2. Admin shares judging URL: `daimyo.cartridge.gg/judge/gj7`
3. Judges authenticate via Discord OAuth, Sensei role verified
4. Judges complete 10-comparison sessions through web UI
5. Admin runs `pnpm jam:rankings --jam gj7` to view results (with optional date filtering)

## Authentication

### Discord OAuth2 Flow

1. Judge visits `/judge/gj7` directly
2. Frontend detects unauthenticated, shows "Login with Discord" button
3. Button calls `/api/auth/discord?jam=gj7` to get OAuth URL (jam slug stored in state)
4. User redirects to Discord authorization
5. Discord redirects to `/api/auth/callback?code={code}&state={state}`
6. Backend exchanges code for Discord user info
7. Backend verifies user has Sensei role via Discord API
8. If not Sensei → redirect to `/error?reason=role`
9. If Sensei → create session (JWT in HTTP-only cookie), redirect to `/judge/{slug}` (slug from state)

### Security

- **State Token**: Stateless HMAC-signed token with 24-hour TTL (prevents CSRF)
  - Format: `{timestamp}.{jam_slug}.{hmac(timestamp + jam_slug, SESSION_SECRET)}`
  - On callback: verify HMAC, check timestamp < 24 hours old, extract jam_slug for redirect
  - No database storage needed
- **Session**: HTTP-only cookies with SameSite=Strict, 7-day expiry
- **Role Check**: Verify Sensei role on login

## GitHub Integration

**GitHub is the source of truth for entries** - no local database sync needed.

### Jam Slug Convention

Jams use the format `gj{x}` where x is the jam number:
- `gj7` - Game Jam 7
- `gj8` - Game Jam 8

This matches the directory structure in `dojoengine/game-jams`.

### Entry Format

A GitHub workflow screens submissions and outputs a standardized `entries.yaml` file.
**Entry IDs are PR numbers** from the game-jams repo.

Each entry includes AI-generated summaries and structured metrics extracted from the screening workflow.

```yaml
# gj7/entries.yaml (generated by screening workflow)
entries:
  - id: "42"
    title: "On-Chain Chess"
    summary_short: "A fully on-chain chess engine built with Dojo..."
    summary_long: "StarkChess is a fully on-chain chess experience..."
    repo_url: "https://github.com/example/stark-chess"
    demo_url: "https://chess.example.com"
    video_url: "https://youtube.com/watch?v=..."
    team: ["@morelucks", "@Itodo-S"]
    metrics:
      classification: "Whole Game"
      team_size: 2
      dojo_contracts: "4 models, 3 systems"
      frontend_sdk: true
      jam_commits_pct: 95
      playability: "Live"
```

**Required Fields**: `id` (PR number), `title`, `summary_short`, `summary_long`, `repo_url`, `team`, `metrics`

**Optional Fields**: `demo_url`, `video_url`

**Metrics** (extracted from screening workflow output):

| Field | Description |
|-------|-------------|
| `classification` | "Whole Game" or "Feature" |
| `team_size` | Number of team members |
| `dojo_contracts` | Contract summary (e.g. "4 models, 3 systems") |
| `frontend_sdk` | Whether client uses @dojoengine SDK |
| `jam_commits_pct` | Percentage of commits within jam window |
| `playability` | "Live", "Video", or "Local" |

### Fetching Entries

Backend fetches entries from GitHub:
```
https://raw.githubusercontent.com/dojoengine/game-jams/main/{slug}/entries.yaml
```

Caching: 5-minute TTL in memory. This balances freshness with minimal GitHub API calls.

## Pairwise Judging

Pairwise preferences are "the atoms of human subjectivity: the simplest distinction a person can make."
Judges express preference strength on a 5-point Likert scale rather than binary choice, capturing richer signal while remaining intuitive.

### Session Structure

- Judges complete sessions of 10 comparisons each
- ~30 seconds per comparison is optimal decision time
- Unlimited sessions per judge (can keep judging until all pairs exhausted)
- Progress auto-saved after each comparison
- Sessions are implicit: `/pair` endpoint tracks comparisons modulo 10
- After 10 comparisons, UI shows "Session complete. Start another?" - clicking continues with next pair

### Pairing Algorithm (Active Ranking)

Uses uncertainty-based sampling via Beta distributions to maximize information gain:

```
For each pair (A, B):
  1. Count wins_A (times A beat B) and wins_B (times B beat A)
  2. Model win probability as Beta(wins_A + 1, wins_B + 1)
  3. Calculate variance: Var = (α × β) / ((α + β)² × (α + β + 1))
  4. Weight pair by variance (higher uncertainty = more valuable comparison)
  5. Filter out pairs already judged by this judge
  6. Sample weighted by variance
```

This surfaces ambiguous pairs where more data is most valuable, potentially reducing required comparisons from O(k²) toward O(k).

### Invalid Pair

Judges can flag a pair as "Invalid Pair" if the two entries should not be compared.
Invalid pairs are stored with `score = NULL` and returned to the pool for other judges.

### Comparison UI

A prompt at the top frames the comparison:
> "Which game better demonstrates the potential of fully on-chain gaming?"

Judge sees two rich entry cards side-by-side (left/right position randomized per comparison).
Each card shows:
- Game title with icon links (play, video, source code)
- Short summary (~50 words, always visible)
- Expandable long summary (~250 words, click to toggle)
- 6 metric chips in a 3x2 grid (Type, Team, Contracts, SDK, Jam Work, Play)

Below the cards, a 5-point Likert scale:
- **Strong A** (1.0) / **Weak A** (0.75) / **Indifferent** (0.5) / **Weak B** (0.25) / **Strong B** (0.0)

Secondary controls:
- **Back** — revisit the previous comparison (client-side only, vote is not undone)
- **Invalid Pair** — flag the pair and move to next

Progress bar shows `X/10` comparisons completed.

After 10 comparisons: "Session complete. Start another session?"

**Note**: Random left/right presentation prevents position bias.
The backend canonicalizes entry order before storing.

### Attention Cost Estimate

Based on ~30 seconds per comparison and active ranking efficiency:
- **Per entry**: ~5 minutes of total judge attention (10 comparisons × 30 sec)
- **20-entry jam**: ~100 minutes total attention across all judges
- **Participant requirement**: ~10 judges contributing two 5-minute sessions each

Active ranking can reduce required comparisons from O(k²) toward O(k) by focusing on uncertain pairs.

## Ranking Algorithm

PageRank-style spectral method using the principal eigenvector of the normalized transition matrix.

### Why Spectral Methods

Spectral methods treat interactions as the only knowable reality - weights emerge as summary statistics rather than hidden truths.
Key advantages:
- **Transitive inference**: Can infer that A likely beats C from A>B and B>C, even without direct comparison
- **Handles intransitivity**: Cycles (A>B>C>A) are interpreted naturally as ties, not errors
- **Computational efficiency**: O(k³ + n) where k = items, n = comparisons

### Algorithm

```
1. Query all comparisons for jam
2. Build N×N transition matrix where N = number of entries
   - For each comparison with score s:
     matrix[A][B] += s       (A's preference weight)
     matrix[B][A] += (1 - s) (B's preference weight)
   - Strong A (1.0): A gets full weight, B gets 0
   - Indifferent (0.5): equal weight to both
   - Strong B (0.0): B gets full weight, A gets 0
3. Normalize each column to sum to 1 (add epsilon to avoid division by zero)
4. Power iteration (100 iterations):
   - Initialize vector = [1/N, 1/N, ..., 1/N]
   - Repeat: newVector = matrix × vector, normalize to sum to 1
5. Normalize eigenvector to 0-100 scores
6. Sort by score descending
```

See reference implementation here: https://github.com/zaratanDotWorld/powerRanker/blob/main/src/power.js

### Edge Cases

- **No comparisons yet**: All entries get neutral score (50)
- **Single entry**: Entry gets perfect score (100)
- **Disconnected entries** (no comparisons involving them): Assign neutral score
- **Cycles/intransitivity**: Handled naturally - entries in cycles get similar scores

### Results Visibility

Rankings are admin-only via CLI: `pnpm jam:rankings --jam gj7`

No public rankings endpoint - admin shares results when ready.

## Database Schema

Minimal schema - just comparisons.
Entries live in GitHub, jam metadata derived from slug.
OAuth state is stateless (HMAC-signed tokens).

### Tables

```sql
-- Pairwise comparisons
jam_comparisons (
  id TEXT PRIMARY KEY,
  jam_slug TEXT NOT NULL,  -- e.g., "gj7", "gj8"
  judge_id TEXT NOT NULL,  -- Discord user ID
  entry_a_id TEXT NOT NULL,  -- PR number (always < entry_b_id alphanumerically)
  entry_b_id TEXT NOT NULL,  -- PR number (always > entry_a_id alphanumerically)
  score REAL,  -- 0.0-1.0 preference for A over B, NULL if skipped
  timestamp BIGINT NOT NULL,
  UNIQUE(jam_slug, judge_id, entry_a_id, entry_b_id)
)
```

**Canonical Ordering**: `entry_a_id` is always alphanumerically less than `entry_b_id`.
The UI presents entries in random left/right order, but the backend canonicalizes before storing.
This ensures the UNIQUE constraint works regardless of presentation order.

**Score Encoding**: `score` is a real number representing preference strength via 5-point Likert scale:
- `1.0` = Strong A
- `0.75` = Weak A
- `0.5` = Indifferent
- `0.25` = Weak B
- `0.0` = Strong B
- `NULL` = Invalid pair

**Just 1 table.** Session progress derived from comparison count. Rankings filtered by date range. OAuth state is stateless.

## API Endpoints

### Authentication (4 endpoints)

**GET /api/auth/discord?jam={slug}**
Generate Discord OAuth URL with state token (includes jam slug for post-auth redirect).
Returns: `{ url: string }`

**GET /api/auth/callback?code={code}&state={state}**
Handle OAuth callback.
Verify Sensei role, create session (7-day JWT), redirect to `/judge/{slug}` (slug extracted from state).

**GET /api/auth/me**
Get current user info.
Returns: `{ id, username, avatar }`

**POST /api/auth/logout**
Clear session cookies.

### Judging (2 endpoints, Sensei role required)

**GET /api/jams/:slug/pair**
Get next comparison pair for authenticated judge.
Returns: `{ entryA: {...}, entryB: {...}, progress: { completed, total: 10 } }`
Returns `{ sessionComplete: true, ... }` after 10 comparisons (judge can continue for more sessions).
Returns `{ allPairsExhausted: true }` when judge has voted on all possible pairs.

**POST /api/jams/:slug/vote**
Record a Likert-scale vote or flag an invalid pair.
Body: `{ entryAId, entryBId, score }` where score is 0.0-1.0 (Likert value).
Or: `{ entryAId, entryBId, score: null, invalid: true }` to flag an invalid pair.
Backend canonicalizes entry order and flips score if needed (symmetric around 0.5).
Returns: `{ recorded: true, sessionComplete: boolean }`

## CLI Scripts

### `pnpm jam:rankings`

View rankings for a game jam.
Optionally filter by date range.

```bash
# All comparisons
pnpm jam:rankings --jam gj7

# Filter by date range
pnpm jam:rankings --jam gj7 --from 2026-01-15 --to 2026-01-31
```

**Options**:
- `--jam` (required): Jam slug (e.g., `gj7`)
- `--from` (optional): Start date for comparisons (ISO format)
- `--to` (optional): End date for comparisons (ISO format)

**Output**:
```
Rankings for gj7
Comparisons: 2026-01-15 to 2026-01-31

 Rank  Score  PR#   Title                          Team
 ----  -----  ---   -----                          ----
    1  87.3    42   On-Chain Chess                 @morelucks, @Itodo-S
    2  82.1    57   Dojo Dungeon                   @dungeondev
    3  71.5    63   Cairo Kart                     @kartmaster, @trackdesigner
  ...

Statistics:
  Total judges: 18
  Total comparisons: 324
  Skipped: 12
  Coverage: 78% of pairs have ≥1 comparison
```

## Frontend

### Tech Stack

- Vite + React (same as planned wallet-linking client)
- React Router for navigation
- Fetch API with credentials: 'include'

### Routes

- `/judge/:slug` - Judging UI (e.g., `/judge/gj7`)
- `/auth/callback` - OAuth callback handler
- `/error` - Error page (shown when non-Sensei tries to login)

Unauthenticated users visiting `/judge/gj7` see "Login with Discord" button.

### Components

**Judge Page**:
```tsx
<ProgressBar completed={7} total={10} />
<ComparisonView
  entryA={entryA}
  entryB={entryB}
  canGoBack={canGoBack}
  onScore={submitScore}
  onInvalidPair={reportInvalidPair}
  onBack={goBack}
/>
```

**ComparisonView**: Prompt banner, two EntryCards side-by-side, LikertScale, Back + Invalid Pair buttons.

**EntryCard**: Title with icon links (play/video/source), short summary, expandable long summary, 6 metric chips.

**LikertScale**: 5 buttons (Strong A, Weak A, Indifferent, Weak B, Strong B) with game titles as anchors.

## Configuration

### New Environment Variables

```bash
# HTTP API
HTTP_PORT=3000
CORS_ORIGIN=https://judge.daimyo.gg

# Discord OAuth
DISCORD_CLIENT_SECRET=...
# OAuth redirect URI is derived automatically from the request Host header.
# Register https://<your-domain>/api/auth/callback in Discord Developer Portal.

# Session
DISCORD_SESSION_SECRET=...  # 32+ character random string

# GitHub
GITHUB_TOKEN=ghp_...
```

### New Dependencies

**Backend**:
- express, cors, express-session
- @octokit/rest
- jsonwebtoken
- js-yaml

**Frontend** (new `/client` directory):
- react, react-dom, react-router-dom
- vite, @vitejs/plugin-react

## Deployment

**Backend**:
- Same Railway deployment as existing bot
- Express runs on HTTP_PORT alongside Discord.js
- Run migrations before deploy: `pnpm --filter backend migrate`

**Frontend**:
- Deploy to Vercel from `/client` directory
- Set `VITE_API_URL=https://daimyo.cartridge.gg`

**DNS**:
- Backend: `daimyo.cartridge.gg`
- Frontend: `judge.daimyo.gg`

## Implementation Phases

### Phase 1: Database & GitHub Fetch

1. Create migration (jam_comparisons table)
2. Implement GitHub service (fetch entries.yaml)
3. Test fetching entries from game-jams repo

### Phase 2: Authentication

1. Add Express alongside Discord.js
2. Implement Discord OAuth routes
3. Implement session middleware with Sensei check
4. Test OAuth flow end-to-end

### Phase 3: Judging API

1. Implement active ranking pairing service (Beta distribution uncertainty)
2. Implement `/api/jams/:slug/pair`, `/api/jams/:slug/vote`
3. Test with curl

### Phase 4: Ranking Algorithm

1. Implement spectral ranking service
2. Create `jam:rankings` CLI script with date range filtering
3. Test with known comparison graphs

### Phase 5: Frontend

1. Create `/client` directory with Vite + React
2. Implement Login and Auth callback pages
3. Implement Judge page with comparison UI and skip button
4. Deploy to Vercel

## Package.json Scripts

Add to `backend/package.json`:

```json
{
  "scripts": {
    "jam:rankings": "tsx src/scripts/jam-rankings.ts"
  }
}
```

## Project Structure

```
daimyo/
├── backend/
│   ├── src/
│   │   ├── api/
│   │   │   ├── index.ts           # Express server setup
│   │   │   ├── routes/
│   │   │   │   ├── auth.ts        # OAuth routes
│   │   │   │   └── jams.ts        # Judging routes
│   │   │   └── middleware/
│   │   │       └── auth.ts        # JWT verification
│   │   ├── services/
│   │   │   ├── github.ts          # GitHub API integration
│   │   │   ├── pairing.ts         # Active ranking pair selection
│   │   │   └── ranking.ts         # Spectral ranking algorithm
│   │   └── scripts/
│   │       └── jam-rankings.ts    # pnpm jam:rankings
│   └── migrations/
│       └── [timestamp]_judging.cjs
├── client/
│   ├── src/
│   │   ├── pages/
│   │   │   ├── Auth.tsx
│   │   │   ├── Judge.tsx
│   │   │   └── Error.tsx
│   │   ├── components/
│   │   │   ├── EntryCard.tsx
│   │   │   ├── ComparisonView.tsx
│   │   │   ├── ProgressBar.tsx
│   │   │   ├── LikertScale.tsx
│   │   │   ├── MetricChip.tsx
│   │   │   └── ExpandableSummary.tsx
│   │   └── hooks/
│   │       └── useJudging.ts
│   ├── package.json
│   └── vite.config.ts
└── spec/
    ├── REPUTATION.md
    ├── BLOCKCHAIN.md
    └── JUDGING.md                  # This document
```

*This specification is a living document and will be updated as the feature develops.*
